# --- –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ï –ò–ú–ü–û–†–¢–´ –î–õ–Ø –í–°–ï–ì–û –§–ê–ô–õ–ê ---
# –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—Å–µ —ç—Ç–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã (pip install ...)

# –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∏ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
import logging
import os
import pickle
import time
import json
import sys
import re
from datetime import timedelta, datetime
from typing import Literal, List, Dict, Optional, Any, Tuple

import pandas as pd
import openpyxl
from openpyxl import Workbook
from pydantic import BaseModel
from fastapi import FastAPI, HTTPException, BackgroundTasks, Body, Depends
from fastapi.responses import JSONResponse, Response
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt, JWTError

# –ò–º–ø–æ—Ä—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Google API
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

# --- –í–ê–ñ–ù–û: –ò–º–ø–æ—Ä—Ç—ã –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ ---
from main import geo_groups, password_data, site_list, GLITCHSPIN_EXTRA_GEOS, VEGASZONE_EXTRA_GEOS
from utils.excel_utils import save_payment_data_to_excel, merge_payment_data
from utils.google_drive import create_google_file, upload_table_to_sheets, get_credentials
from utils.google_drive import finalize_google_sheet_formatting, set_sheet_permissions

# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç Telegram –±–æ—Ç–∞
try:
    from telegram_bot_fixed import send_sheet_notification_to_all_sync, init_bot_instance
    from telegram_config import TelegramConfig
    TELEGRAM_AVAILABLE = True
except ImportError:
    TELEGRAM_AVAILABLE = False
    logging.warning("‚ö†Ô∏è Telegram –º–æ–¥—É–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã.")

from extractors.ritzo_extractor import RitzoExtractor
from extractors.rolling_extractor import RollingExtractor
from extractors.nfs_extractor import NeedForSpinExtractor
from extractors.wld_extractor import WildTokyoExtractor
from extractors.godofwins_extractor import GodofwinsExtractor
from extractors.hugo_extractor import HugoExtractor
from extractors.winshark_extractor import WinsharkExtractor
from extractors.spinlander_extractor import SpinlanderExtractor
from extractors.slota_extractor import SlotaExtractor
from extractors.spinline_extractor import SpinlineExtractor
from extractors.glitchspin_extractor import GlitchSpinExtractor
from extractors.azur_extractor import AzurSlotExtractor
from extractors.slotsvader_extractor import SlotsVaderExtractor
from extractors.vegazone_extractor import VegazoneExtractor
from extractors.ludios_extractor import LudiosExtractor
from extractors.spinempire_extractor import SpinEmpireExtractor


# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø ---
LOG_FILE = os.path.join(os.path.dirname(__file__), "export_debug.log")
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, mode='w', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

# --- –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ –ò –ê–£–¢–ï–ù–¢–ò–§–ò–ö–ê–¶–ò–Ø ---
SECRET_KEY = "supersecretkey123"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

users_db = {
    "admin": {"password": "123", "role": "admin"},
    "qa": {"password": "qa123", "role": "qa"},
    "viewer": {"password": "viewer123", "role": "viewer"},
}

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None or username not in users_db:
            raise HTTPException(status_code=401, detail="Invalid token")
        return {"username": username, "role": users_db[username]["role"]}
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def extract_tags(name):
    tags = []
    dep_match = None
    for i in range(10):
        if f"{i}dep" in name.lower():
            dep_match = f"{i}DEP"
            break
    if dep_match:
        tags.append(dep_match)
    if "aff" in name.lower():
        tags.append("AFF")
    if "mob" in name.lower():
        tags.append("MOB")
    return tags

def extract_conditions_from_name(name: str) -> str:
    if not isinstance(name, str):
        return "ALL"
    tags = set()
    name_lower = name.lower()
    dep_match = re.search(r'(\d+)dep', name_lower)
    if dep_match:
        tags.add(f"{dep_match.group(1)}DEP")
    if "aff" in name_lower:
        tags.add("AFF")
    if "mob" in name_lower:
        tags.add("MOB")
    if not tags:
        return "ALL"
    return "\n".join(sorted(list(tags)))


# --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø FastAPI ---
app = FastAPI()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –±–æ—Ç–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
@app.on_event("startup")
async def startup_event():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    if TELEGRAM_AVAILABLE:
        if TelegramConfig.is_configured():
            bot_token = TelegramConfig.get_bot_token()
            init_bot_instance(bot_token)
            logging.info("‚úÖ Telegram –±–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è –º–∞—Å—Å–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
        else:
            logging.warning("‚ö†Ô∏è Telegram –±–æ—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã.")
    else:
        logging.info("‚ÑπÔ∏è Telegram –º–æ–¥—É–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")

def safe_send_telegram_notification(sheet_url: str, project: str, geo: str = None, env: str = "prod", export_type: str = "single"):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
    if TELEGRAM_AVAILABLE:
        try:
            send_sheet_notification_to_all_sync(
                sheet_url=sheet_url,
                project=project,
                geo=geo,
                env=env,
                export_type=export_type
            )
            logging.info(f"‚úÖ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º: {project} - {export_type}")
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
    else:
        logging.info("üì± Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã")

# --- PYDANTIC –ú–û–î–ï–õ–ò –î–õ–Ø –ó–ê–ü–†–û–°–û–í ---
class LoginTestRequest(BaseModel):
    project: str
    login: Optional[str] = None
    geo: str
    env: Literal["stage", "prod"]
    mode: Optional[str] = None

class MethodTestRequest(BaseModel):
    project: str
    geo: str
    login: str
    mode: str
    env: Literal["stage", "prod"]

class FullProjectExportRequest(BaseModel):
    project: str
    env: Literal["stage", "prod"]


# --- –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
EXTRACTORS = {
    site["name"]: (site["extractor_class"], site["stage_url"], site["prod_url"])
    for site in site_list
}

# 1) –ü–û–ú–û–©–ù–ò–ö–ò
def _key_join(title: str, name: str) -> str:
    return f"{(title or '').strip()}|||{(name or '').strip()}"

def _extract_pairs_and_minlist(methods_or_titles, names_opt=None):
    """
    –£–Ω–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –æ–±–∞ —Ñ–æ—Ä–º–∞—Ç–∞:
      - —Å—Ç–∞—Ä—ã–π: methods_or_titles = List[str], names_opt = List[str]
      - –Ω–æ–≤—ã–π:  methods_or_titles = List[dict] —Å –ø–æ–ª—è–º–∏ title/name/min_deposit
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
      pairs:    List[Tuple[str, str]]
      min_list: List[Dict[str, Any]]  # [{"title","name","min_deposit","currency"?, "min_source"?, ...}]
    """
    pairs, min_list = [], []

    if isinstance(methods_or_titles, list) and methods_or_titles and isinstance(methods_or_titles[0], dict):
        for it in methods_or_titles:
            t = (it.get("title") or it.get("alias") or it.get("name") or "").strip()
            n = (it.get("name") or it.get("alias") or it.get("doc_id") or "").strip()
            if not t or not n:
                continue
            pairs.append((t, n))
            if it.get("min_deposit") is not None:
                try:
                    row = {
                        "title": t,
                        "name": n,
                        "min_deposit": float(it["min_deposit"]),
                    }
                    if it.get("currency"):    row["currency"] = it["currency"]
                    if it.get("min_source"):  row["min_source"] = it["min_source"]
                    min_list.append(row)
                except (ValueError, TypeError):
                    continue
    else:
        if not isinstance(names_opt, list):
            names_opt = []
        pairs = list(zip(methods_or_titles or [], names_opt))
    return pairs, min_list
    
def _is_geo_forbidden_for_project(project: str, geo: str) -> bool:
    """
    –ï—Å–ª–∏ —É –∫–ª–∞—Å—Å–∞ —ç–∫—Å—Ç—Ä–∞–∫—Ç–æ—Ä–∞ –µ—Å—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ is_geo_forbidden_static(geo),
    –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, —á—Ç–æ–±—ã —Ä–µ—à–∏—Ç—å ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å GEO –∏–ª–∏ –Ω–µ—Ç.
    """
    try:
        extractor_class, _, _ = EXTRACTORS[project]
    except Exception:
        return False

    # –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –Ω–∞ –∫–ª–∞—Å—Å–µ
    if hasattr(extractor_class, "is_geo_forbidden_static"):
        try:
            return bool(extractor_class.is_geo_forbidden_static(geo))
        except Exception:
            return False

    # –ù–∞ –≤—Å—è–∫–∏–π ‚Äî –∏–Ω—Å—Ç–∞–Ω—Å –∏ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤—ã–π –º–µ—Ç–æ–¥
    try:
        tmp = extractor_class(login="", password="", base_url="")
        if hasattr(tmp, "is_geo_forbidden"):
            return bool(tmp.is_geo_forbidden(geo))
    except Exception:
        pass
    return False

# 2) GET_METHODS_ONLY
def get_methods_only(project: str, geo: str, env: str, login: str):
    if project not in EXTRACTORS:
        raise HTTPException(status_code=400, detail="Unknown project")
    extractor_class, stage_url, prod_url = EXTRACTORS[project]
    url = stage_url if env == "stage" else prod_url
    user_agent = (
        "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
        if "mobi" in login
        else "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15"
    )
    extractor = extractor_class(login, password_data, user_agent=user_agent, base_url=url)
    if not extractor.authenticate():
        return {"success": False, "error": "Authentication failed"}
    try:
        # üîß –û–¢–õ–ê–î–ö–ê: –õ–æ–≥–∏—Ä—É–µ–º –≤—ã–∑–æ–≤ get_payment_and_withdraw_systems
        logging.info(f"[API] üîç –í—ã–∑—ã–≤–∞–µ–º get_payment_and_withdraw_systems –¥–ª—è {project}/{geo}/{login}")
        deposit, withdraw, dep_names, wd_names, currency, dep_count, recommended = extractor.get_payment_and_withdraw_systems(geo)
        
        # üîß –û–¢–õ–ê–î–ö–ê: –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        logging.info(f"[API] üìä –ü–æ–ª—É—á–∏–ª–∏: deposit={len(deposit) if hasattr(deposit, '__len__') else type(deposit)}, dep_names={len(dep_names) if hasattr(dep_names, '__len__') else type(dep_names)}")
        
        # üîß –û–¢–õ–ê–î–ö–ê: –ò—â–µ–º Skrill –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö
        skrill_count = 0
        if hasattr(deposit, '__iter__'):
            for item in deposit:
                if isinstance(item, dict):
                    title = item.get('title', '')
                    name = item.get('name', '')
                elif isinstance(item, str):
                    title = item
                    name = ''
                else:
                    continue
                
                if 'skrill' in title.lower() or 'skrill' in name.lower():
                    skrill_count += 1
                    logging.info(f"[API] üí∞ SKRILL –≤ deposit #{skrill_count}: \"{title}\" -> \"{name}\"")
        
        logging.info(f"[API] üìä –í—Å–µ–≥–æ Skrill –≤ deposit: {skrill_count}")

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ–±–∞ —Ñ–æ—Ä–º–∞—Ç–∞
        deposit_pairs, dep_min_list = _extract_pairs_and_minlist(deposit, dep_names)
        withdraw_pairs, wd_min_list = _extract_pairs_and_minlist(withdraw, wd_names)
        min_deposit_list = dep_min_list + wd_min_list

        # –î–ª—è —Ñ—Ä–æ–Ω—Ç–∞: –º–∞–ø–∞ –∫–ª—é—á->–∑–Ω–∞—á–µ–Ω–∏–µ –∏ –ª–µ–≥–∞—Å–∏-–º–∞—Å—Å–∏–≤
        min_deposit_by_key = {
            _key_join(x["title"], x["name"]): x["min_deposit"] for x in min_deposit_list
        }
        min_deposits_legacy = [
            {
                "Title": x.get("title", ""),
                "Name": x.get("name", ""),
                "MinDeposit": x.get("min_deposit", None),
                "Currency": x.get("currency", "") or currency or extractor.currency or ""
            }
            for x in min_deposit_list
        ]

        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è recommended + –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –ø–æ –ø–æ—Ä—è–¥–∫—É
        # recommended –ø—Ä–∏—Ö–æ–¥–∏—Ç set[(title,name)], –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø—Ä–æ–±–µ–ª—ã
        recommended_norm = {(t.strip(), n.strip()) for (t, n) in (recommended or set())}
        recommended_pairs: List[Tuple[str, str]] = []
        seen_rec: set = set()
        for pair in (deposit_pairs + withdraw_pairs):
            p = (pair[0].strip(), pair[1].strip())
            if p in recommended_norm and p not in seen_rec:
                recommended_pairs.append(pair)
                seen_rec.add(p)

        return {
            "success": True,
            "currency": currency or extractor.currency,
            "deposit_methods": deposit_pairs,
            "withdraw_methods": withdraw_pairs,
            "recommended_methods": recommended_pairs,
            "min_deposit_map": min_deposit_list,       # –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç (list of dicts)
            "min_deposit_by_key": min_deposit_by_key,  # –±—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø –ø–æ –∫–ª—é—á—É
            "min_deposits": min_deposits_legacy,       # –õ–ï–ì–ê–°–ò –¥–ª—è —Å—Ç–∞—Ä–æ–≥–æ —Ñ—Ä–æ–Ω—Ç–∞
            "debug": {
                "recommended_pairs": list(recommended_norm),
                "deposit_raw_type": type(deposit).__name__,
                "withdraw_raw_type": type(withdraw).__name__,
                "deposit_len": len(deposit) if isinstance(deposit, list) else None,
                "withdraw_len": len(withdraw) if isinstance(withdraw, list) else None
            }
        }
    except Exception as e:
        logging.exception(f"Error in get_methods_only for {project}/{geo}/{login}: {e}")
        return {"success": False, "error": str(e)}

def format_data_for_sheets(project: str, geo: str, env: str):
    """
    üîß –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –§–æ—Ä–º–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è Google Sheets –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –±—ç–∫–µ–Ω–¥–∞
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–æ—Ç–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –≤ —Ç–æ–º –∂–µ —Ñ–æ—Ä–º–∞—Ç–µ, —á—Ç–æ –æ–∂–∏–¥–∞–µ—Ç —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
    """
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –º–µ—Ç–æ–¥—ã
    methods_data = get_all_methods_for_geo(project=project, geo=geo, env=env)
    
    if not methods_data.get("success"):
        return {"success": False, "error": methods_data.get("error", "Unknown error")}
    
    deposit_methods = methods_data.get("deposit_methods", [])
    withdraw_methods = methods_data.get("withdraw_methods", [])
    recommended_methods = methods_data.get("recommended_methods", [])
    min_deposit_by_key = methods_data.get("min_deposit_by_key", {})
    currency = methods_data.get("currency", "EUR")
    
    # –£–±–∏—Ä–∞–µ–º –æ—Ç–ª–∞–¥–∫—É –¥–ª—è —á–∏—Å—Ç–æ—Ç—ã
    
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –º–µ—Ç–æ–¥—ã –ø–æ title
    title_groups = {}
    method_types = {}
    recommended_set = set()
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    for title, name in recommended_methods:
        recommended_set.add(f"{title}|||{name}")
    
    # üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –º–µ—Ç–æ–¥—ã –ø–æ —Ç–∏–ø–∞–º –æ—Ç–¥–µ–ª—å–Ω–æ
    
    # –°–Ω–∞—á–∞–ª–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º deposit –º–µ—Ç–æ–¥—ã
    for title, name in deposit_methods:
        key = f"{title}|||{name}"
        
        if title not in title_groups:
            title_groups[title] = {
                "names": set(),
                "conditions": set(),
                "hasDeposit": False,
                "hasWithdraw": False,
                "isRecommended": False
            }
        
        title_groups[title]["names"].add(name)
        title_groups[title]["hasDeposit"] = True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
        if key in recommended_set:
            title_groups[title]["isRecommended"] = True
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —É—Å–ª–æ–≤–∏—è –∏–∑ name
        conditions = extract_conditions_from_name(name)
        title_groups[title]["conditions"].update(conditions)
    
    # –ü–æ—Ç–æ–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º withdraw –º–µ—Ç–æ–¥—ã
    for title, name in withdraw_methods:
        key = f"{title}|||{name}"
        
        if title not in title_groups:
            title_groups[title] = {
                "names": set(),
                "conditions": set(),
                "hasDeposit": False,
                "hasWithdraw": False,
                "isRecommended": False
            }
        
        title_groups[title]["names"].add(name)
        title_groups[title]["hasWithdraw"] = True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
        if key in recommended_set:
            title_groups[title]["isRecommended"] = True
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —É—Å–ª–æ–≤–∏—è –∏–∑ name
        conditions = extract_conditions_from_name(name)
        title_groups[title]["conditions"].update(conditions)
    
    # –£–±–∏—Ä–∞–µ–º –æ—Ç–ª–∞–¥–∫—É
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è Google Sheets
    sheets_data = []
    
    for title, group_data in title_groups.items():
        # –ü–æ–ª—É—á–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç
        min_deposit = None
        for name in group_data["names"]:
            key = f"{title}|||{name}"
            if key in min_deposit_by_key:
                dep_val = min_deposit_by_key[key]
                if isinstance(dep_val, (int, float)) and dep_val > 0:
                    if min_deposit is None or dep_val < min_deposit:
                        min_deposit = dep_val
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —É—Å–ª–æ–≤–∏—è
        conditions_str = "ALL"
        if group_data["conditions"]:
            conditions_str = "\n".join(sorted(group_data["conditions"]))
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è Google Sheets
        row = {
            "Paymethod": title,
            "Payment Name": "\n".join(sorted(group_data["names"])),
            "Currency": currency,
            "Deposit": "YES" if group_data["hasDeposit"] else "NO",
            "Withdraw": "YES" if group_data["hasWithdraw"] else "NO", 
            "Status": "PROD" if env == "prod" else "STAGE",
            "Details": conditions_str,
            "Min Dep": f"{min_deposit} {currency}".strip() if min_deposit else "‚Äî",
            "Recommended": "‚≠ê" if group_data["isRecommended"] else ""
        }
        
        sheets_data.append(row)
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º: —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ —Å–Ω–∞—á–∞–ª–∞, –ø–æ—Ç–æ–º –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É
    sheets_data.sort(key=lambda x: (not x["Recommended"], x["Paymethod"]))
    
    logging.info(f"[format_data_for_sheets] üìä –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ {len(sheets_data)} —Å—Ç—Ä–æ–∫ –¥–ª—è Google Sheets")
    
    return {
        "success": True,
        "data": sheets_data,
        "currency": currency,
        "total_methods": len(sheets_data),
        "geo": geo,
        "project": project,
        "env": env
    }

def extract_conditions_from_name(name: str) -> set:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —É—Å–ª–æ–≤–∏—è –∏–∑ –∏–º–µ–Ω–∏ –º–µ—Ç–æ–¥–∞"""
    conditions = set()
    
    # –ò—â–µ–º DEP –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    if "0DEP" in name:
        conditions.add("0DEP")
    elif "1DEP" in name:
        conditions.add("1DEP")
    elif "2DEP" in name:
        conditions.add("2DEP")
    elif "3DEP" in name:
        conditions.add("3DEP")
    elif "4DEP" in name:
        conditions.add("4DEP")
    
    # –ò—â–µ–º AFF
    if "//aff" in name or "_aff" in name:
        conditions.add("AFF")
    
    # –ò—â–µ–º MOB
    if "//mob" in name or "_mob" in name or "mobi" in name.lower():
        conditions.add("MOB")
    
    return conditions

def get_all_methods_for_geo(project: str, geo: str, env: str):
    """
    üîß –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –°–æ–±–∏—Ä–∞–µ—Ç –º–µ—Ç–æ–¥—ã —Å–æ –í–°–ï–• –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ GEO
    –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —É–≤–∏–¥–µ—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –º–µ—Ç–æ–¥—ã (0DEP Skrill + 1DEP Skrill + 3DEP Skrill)
    """
    if project not in EXTRACTORS:
        raise HTTPException(status_code=400, detail="Unknown project")
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ GEO —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–µ–∫—Ç–∞
    if project == "Glitchspin":
        merged_geo_groups = {**geo_groups, **GLITCHSPIN_EXTRA_GEOS}
    elif project == "Vegazone":
        merged_geo_groups = {**geo_groups, **VEGASZONE_EXTRA_GEOS}
    else:
        merged_geo_groups = geo_groups
    
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ GEO
    if geo in merged_geo_groups:
        login_list = merged_geo_groups[geo]
    else:
        # –ï—Å–ª–∏ —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –Ω–µ—Ç, –ø—Ä–æ–±—É–µ–º –±–∞–∑–æ–≤–æ–µ GEO (–±–µ–∑ _desktop/_mobile)
        base_geo = geo.split('_')[0]
        if base_geo in merged_geo_groups:
            login_list = merged_geo_groups[base_geo]
        else:
            return {"success": False, "error": f"Unknown GEO: {geo} (base: {base_geo})"}
    
    
    logging.info(f"[get_all_methods_for_geo] üîç –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º {len(login_list)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è {project}/{geo}")
    
    all_deposit_pairs = []
    all_withdraw_pairs = []
    all_recommended_pairs = []
    all_min_deposit_list = []
    # üîß –£–ë–†–ê–ù–ê –í–°–Ø –õ–û–ì–ò–ö–ê –§–ò–õ–¨–¢–†–ê–¶–ò–ò –ò –î–ï–î–£–ü–õ–ò–ö–ê–¶–ò–ò
    
    successful_accounts = 0
    detected_currency = None  # –î–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–∞–ª—é—Ç—ã
    
    for i, login in enumerate(login_list):
        try:
            logging.info(f"[get_all_methods_for_geo] üìä –ê–∫–∫–∞—É–Ω—Ç {i+1}/{len(login_list)}: {login}")
            
            # –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–æ–¥—ã –¥–ª—è —ç—Ç–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
            result = get_methods_only(project=project, geo=geo, env=env, login=login)
            
            if not result.get("success"):
                logging.warning(f"[get_all_methods_for_geo] ‚ùå –ê–∫–∫–∞—É–Ω—Ç {login} –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç: {result.get('error', 'Unknown error')}")
                continue
            
            successful_accounts += 1
            
            # üîß –°–û–•–†–ê–ù–Ø–ï–ú –í–ê–õ–Æ–¢–£ –ò–ó –ü–ï–†–í–û–ì–û –£–°–ü–ï–®–ù–û–ì–û –ê–ö–ö–ê–£–ù–¢–ê
            if detected_currency is None:
                detected_currency = result.get("currency")
                if detected_currency:
                    logging.info(f"[get_all_methods_for_geo] üí∞ –í–∞–ª—é—Ç–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∏–∑ {login}: {detected_currency}")
            
            # üîß –î–û–ë–ê–í–õ–Ø–ï–ú –í–°–ï –ú–ï–¢–û–î–´ –ë–ï–ó –ö–ê–ö–û–ô-–õ–ò–ë–û –§–ò–õ–¨–¢–†–ê–¶–ò–ò
            deposit_methods = result.get("deposit_methods", [])
            withdraw_methods = result.get("withdraw_methods", [])
            recommended_methods = result.get("recommended_methods", [])
            min_deposit_map = result.get("min_deposit_map", [])
            
            # –î–æ–±–∞–≤–ª—è–µ–º –í–°–ï deposit –º–µ—Ç–æ–¥—ã
            for method in deposit_methods:
                if isinstance(method, (list, tuple)) and len(method) >= 2:
                    all_deposit_pairs.append(method)
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º Skrill –º–µ—Ç–æ–¥—ã
                    title, name = method[0], method[1]
                    if 'skrill' in title.lower() or 'skrill' in name.lower():
                        logging.info(f"[get_all_methods_for_geo] üí∞ –î–û–ë–ê–í–õ–ï–ù SKRILL –∏–∑ {login}: \"{title}\" -> \"{name}\"")
            
            # –î–æ–±–∞–≤–ª—è–µ–º –í–°–ï withdraw –º–µ—Ç–æ–¥—ã
            for method in withdraw_methods:
                if isinstance(method, (list, tuple)) and len(method) >= 2:
                    all_withdraw_pairs.append(method)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –í–°–ï recommended –º–µ—Ç–æ–¥—ã
            for method in recommended_methods:
                if isinstance(method, (list, tuple)) and len(method) >= 2:
                    all_recommended_pairs.append(method)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –í–°–ï min_deposit –¥–∞–Ω–Ω—ã–µ
            all_min_deposit_list.extend(min_deposit_map)
            
        except Exception as e:
            logging.error(f"[get_all_methods_for_geo] ‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞ {login}: {e}")
            continue
    
    # –°–æ–∑–¥–∞–µ–º min_deposit_by_key
    min_deposit_by_key = {}
    for item in all_min_deposit_list:
        if isinstance(item, dict) and "title" in item and "name" in item:
            key = _key_join(item["title"], item["name"])
            if "min_deposit" in item:
                min_deposit_by_key[key] = item["min_deposit"]
    
    logging.info(f"[get_all_methods_for_geo] ‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {successful_accounts}/{len(login_list)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤")
    logging.info(f"[get_all_methods_for_geo] üìä –ò—Ç–æ–≥–æ: deposit={len(all_deposit_pairs)}, withdraw={len(all_withdraw_pairs)}")
    
    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º Skrill –º–µ—Ç–æ–¥—ã –≤ –∏—Ç–æ–≥–µ
    total_skrill = sum(1 for method in all_deposit_pairs 
                      if isinstance(method, (list, tuple)) and len(method) >= 2 
                      and ('skrill' in method[0].lower() or 'skrill' in method[1].lower()))
    
    logging.info(f"[get_all_methods_for_geo] üí∞ –ò—Ç–æ–≥–æ Skrill –º–µ—Ç–æ–¥–æ–≤: {total_skrill}")
    
    return {
        "success": True,
        "deposit_methods": all_deposit_pairs,
        "withdraw_methods": all_withdraw_pairs,
        "recommended_methods": all_recommended_pairs,
        "min_deposit_map": all_min_deposit_list,
        "min_deposit_by_key": min_deposit_by_key,
        "currency": detected_currency or "EUR",  # üîß –î–û–ë–ê–í–õ–Ø–ï–ú –í–ê–õ–Æ–¢–£
        "accounts_processed": successful_accounts,
        "total_accounts": len(login_list),
        "debug": {
            "total_skrill": total_skrill,
            "accounts_used": [login for login in login_list[:successful_accounts]],
            "detected_currency": detected_currency
        }
    }

def run_login_check(project: str, geo: str, env: str, login: str):
    if project not in EXTRACTORS:
        raise HTTPException(status_code=400, detail="Unknown project")
    extractor_class, stage_url, prod_url = EXTRACTORS[project]
    url = stage_url if env == "stage" else prod_url
    user_agent = (
        "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
        if "mobi" in login
        else "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15"
    )
    extractor = extractor_class(login, password_data, user_agent=user_agent, base_url=url)
    if not extractor.authenticate():
        raise HTTPException(status_code=401, detail="Authentication failed")
    return {
        "success": True,
        "currency": extractor.currency,
        "deposit_count": extractor.deposit_count
    }

# --- API –≠–ù–î–ü–û–ò–ù–¢–´ ---

@app.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = users_db.get(form_data.username)
    if not user or user["password"] != form_data.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    access_token = create_access_token(data={"sub": form_data.username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/me")
def read_me(user: dict = Depends(get_current_user)):
    return user

@app.get("/list-projects")
def list_projects():
    return [
        {"name": site["name"], "stage_url": site["stage_url"], "prod_url": site["prod_url"]}
        for site in site_list
    ]

@app.get("/geo-groups")
def get_geo_groups():
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—ã–µ GEO + –¥–æ–ø. GEO –¥–ª—è Glitchspin –∏ Vegazone, —á—Ç–æ–±—ã —Ñ—Ä–æ–Ω—Ç –∏—Ö –≤–∏–¥–µ–ª
    merged = {**geo_groups, **GLITCHSPIN_EXTRA_GEOS, **VEGASZONE_EXTRA_GEOS}
    return merged

@app.post("/get-methods-only")
def get_methods_only_endpoint(request: LoginTestRequest):
    # ‚¨áÔ∏è –Ω–æ–≤–æ–µ:
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {
            "success": True,
            "deposit_methods": [],
            "withdraw_methods": [],
            "recommended_methods": [],
            "skipped_geo": True,
            "reason": "forbidden_geo"
        }

    # üîß –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í–°–ï–ì–î–ê –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—É—é –ª–æ–≥–∏–∫—É –≤—Å–µ—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤
    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π login –∏ —Å–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–æ –≤—Å–µ—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è GEO
    logging.info(f"[get_methods_only] –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—É—é –ª–æ–≥–∏–∫—É –¥–ª—è {request.project}/{request.geo} (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º login={request.login})")
    
    # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)
    
    if not raw_data.get("success"):
        return raw_data
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    deposit_methods = raw_data.get("deposit_methods", [])
    withdraw_methods = raw_data.get("withdraw_methods", [])
    recommended_methods = raw_data.get("recommended_methods", [])
    min_deposit_by_key = raw_data.get("min_deposit_by_key", {})
    
    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –º–µ—Ç–æ–¥–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    methods = []
    method_names = set()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ deposit –º–µ—Ç–æ–¥—ã
    for title, name in deposit_methods:
        if name not in method_names:
            method_names.add(name)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
            is_recommended = any(rt == title and rn == name for rt, rn in recommended_methods)
            
            # –ü–æ–ª—É—á–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç
            min_deposit = min_deposit_by_key.get(f"{title}|||{name}", 0)
            
            methods.append({
                "title": title,
                "name": name,
                "isRecommended": is_recommended,
                "hasDeposit": True,
                "hasWithdraw": False,  # –ü–æ–∫–∞ —Ç–æ–ª—å–∫–æ deposit
                "minDeposit": min_deposit
            })
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–æ–¥—ã –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –∏ –≤ withdraw
    withdraw_names = set(name for title, name in withdraw_methods)
    for method in methods:
        if method["name"] in withdraw_names:
            method["hasWithdraw"] = True
    
    # –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–æ–¥—ã –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –≤ withdraw
    for title, name in withdraw_methods:
        if name not in method_names:
            method_names.add(name)
            
            methods.append({
                "title": title,
                "name": name,
                "isRecommended": False,
                "hasDeposit": False,
                "hasWithdraw": True,
                "minDeposit": 0
            })
    
    return {
        "success": True,
        "methods": methods,
        "currency": raw_data.get("currency"),
        "accounts_processed": raw_data.get("accounts_processed", 0),
        "total_accounts": raw_data.get("total_accounts", 0)
    }

@app.post("/get-all-methods-for-geo")
def get_all_methods_for_geo_endpoint(request: LoginTestRequest):
    """
    üîß –ù–û–í–´–ô ENDPOINT: –ü–æ–ª—É—á–∞–µ—Ç –º–µ—Ç–æ–¥—ã —Å–æ –í–°–ï–• –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ GEO
    –û–±—ä–µ–¥–∏–Ω—è–µ—Ç –º–µ—Ç–æ–¥—ã –∏–∑ –≤—Å–µ—Ö 5 –∞–∫–∫–∞—É–Ω—Ç–æ–≤, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É
    """
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {
            "success": True,
            "deposit_methods": [],
            "withdraw_methods": [],
            "recommended_methods": [],
            "skipped_geo": True,
            "reason": "forbidden_geo"
        }

    return get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)

@app.post("/get-sheets-data")
def get_sheets_data_endpoint(request: LoginTestRequest):
    """
    üîß –ù–û–í–´–ô ENDPOINT: –§–æ—Ä–º–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –Ω–∞–ø—Ä—è–º—É—é –¥–ª—è Google Sheets
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–æ—Ç–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞
    """
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {
            "success": True,
            "data": [],
            "skipped_geo": True,
            "reason": "forbidden_geo"
        }

    return format_data_for_sheets(project=request.project, geo=request.geo, env=request.env)

@app.post("/debug-skrill")
def debug_skrill_endpoint(request: LoginTestRequest):
    """
    üîß –û–¢–õ–ê–î–û–ß–ù–´–ô ENDPOINT: –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–µ—Ç–∞–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ Skrill –º–µ—Ç–æ–¥–æ–≤
    """
    # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)
    
    if not raw_data.get("success"):
        return {"success": False, "error": raw_data.get("error")}
    
    deposit_methods = raw_data.get("deposit_methods", [])
    
    # –ò—â–µ–º –≤—Å–µ Skrill –º–µ—Ç–æ–¥—ã
    skrill_methods = []
    for method in deposit_methods:
        if isinstance(method, (list, tuple)) and len(method) >= 2:
            title, name = method[0], method[1]
            if 'skrill' in title.lower() or 'skrill' in name.lower():
                skrill_methods.append({"title": title, "name": name})
    
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ title
    title_groups = {}
    for item in skrill_methods:
        title = item["title"]
        if title not in title_groups:
            title_groups[title] = []
        title_groups[title].append(item["name"])
    
    return {
        "success": True,
        "total_skrill_methods": len(skrill_methods),
        "skrill_methods": skrill_methods,
        "title_groups": title_groups,
        "unique_titles": list(title_groups.keys())
    }

@app.post("/debug-sheets-processing")
def debug_sheets_processing_endpoint(request: LoginTestRequest):
    """
    üîß –û–¢–õ–ê–î–û–ß–ù–´–ô ENDPOINT: –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–æ—à–∞–≥–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ format_data_for_sheets
    """
    # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)
    
    if not raw_data.get("success"):
        return {"success": False, "error": raw_data.get("error")}
    
    deposit_methods = raw_data.get("deposit_methods", [])
    
    # –®–∞–≥ 1: –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    skrill_input = [(title, name) for title, name in deposit_methods 
                   if 'skrill' in title.lower() or 'skrill' in name.lower()]
    
    # –®–∞–≥ 2: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞
    title_groups = {}
    for title, name in skrill_input:
        if title not in title_groups:
            title_groups[title] = {"names": set(), "count": 0}
        title_groups[title]["names"].add(name)
        title_groups[title]["count"] += 1
    
    # –®–∞–≥ 3: –§–∏–Ω–∞–ª—å–Ω—ã–µ –≥—Ä—É–ø–ø—ã
    final_groups = {}
    for title, data in title_groups.items():
        final_groups[title] = {
            "names": list(data["names"]),
            "count": data["count"]
        }
    
    return {
        "success": True,
        "step1_input": {
            "total_skrill": len(skrill_input),
            "methods": [{"title": title, "name": name} for title, name in skrill_input],
            "unique_titles": list(set(title for title, name in skrill_input))
        },
        "step2_grouping": final_groups,
        "step3_should_create": len(final_groups)
    }

@app.post("/debug-minimal-sheets")
def debug_minimal_sheets_endpoint(request: LoginTestRequest):
    """
    üîß –ú–ò–ù–ò–ú–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø format_data_for_sheets —Ç–æ–ª—å–∫–æ –¥–ª—è Skrill
    """
    # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)
    
    if not raw_data.get("success"):
        return {"success": False, "error": raw_data.get("error")}
    
    deposit_methods = raw_data.get("deposit_methods", [])
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ Skrill
    skrill_methods = [(title, name) for title, name in deposit_methods 
                     if 'skrill' in title.lower() or 'skrill' in name.lower()]
    
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ title (–∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏)
    title_groups = {}
    for title, name in skrill_methods:
        if title not in title_groups:
            title_groups[title] = {"names": set()}
        title_groups[title]["names"].add(name)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    sheets_data = []
    for title, group_data in title_groups.items():
        row = {
            "Paymethod": title,
            "Payment Name": "\\n".join(sorted(group_data["names"])),
            "Details": "TEST"
        }
        sheets_data.append(row)
    
    return {
        "success": True,
        "input_skrill_count": len(skrill_methods),
        "input_unique_titles": list(set(title for title, name in skrill_methods)),
        "groups_created": len(title_groups),
        "final_rows": len(sheets_data),
        "sheets_data": sheets_data
    }

@app.post("/get-sheets-data-fixed")
def get_sheets_data_fixed_endpoint(request: LoginTestRequest):
    """
    üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–∞–±–æ—á—É—é –ª–æ–≥–∏–∫—É –∏–∑ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    """
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {
            "success": True,
            "data": [],
            "skipped_geo": True,
            "reason": "forbidden_geo"
        }

    # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = get_all_methods_for_geo(project=request.project, geo=request.geo, env=request.env)
    
    if not raw_data.get("success"):
        return {"success": False, "error": raw_data.get("error", "Unknown error")}
    
    deposit_methods = raw_data.get("deposit_methods", [])
    withdraw_methods = raw_data.get("withdraw_methods", [])
    recommended_methods = raw_data.get("recommended_methods", [])
    min_deposit_by_key = raw_data.get("min_deposit_by_key", {})
    currency = raw_data.get("currency", "EUR")
    
    # –£–±–∏—Ä–∞–µ–º –æ—Ç–ª–∞–¥–∫—É - endpoint –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
    
    # –°–æ–∑–¥–∞–µ–º set —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
    recommended_set = set()
    for title, name in recommended_methods:
        recommended_set.add(f"{title}|||{name}")
    
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –†–ê–ë–û–ß–£–Æ –õ–û–ì–ò–ö–£: –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –º–µ—Ç–æ–¥—ã –ø–æ title
    title_groups = {}
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º deposit –º–µ—Ç–æ–¥—ã
    for title, name in deposit_methods:
        if title not in title_groups:
            title_groups[title] = {
                "names": set(),
                "conditions": set(),
                "hasDeposit": False,
                "hasWithdraw": False,
                "isRecommended": False
            }
        
        title_groups[title]["names"].add(name)
        title_groups[title]["hasDeposit"] = True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
        key = f"{title}|||{name}"
        if key in recommended_set:
            title_groups[title]["isRecommended"] = True
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —É—Å–ª–æ–≤–∏—è
        conditions = extract_conditions_from_name(name)
        title_groups[title]["conditions"].update(conditions)
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º withdraw –º–µ—Ç–æ–¥—ã
    for title, name in withdraw_methods:
        if title not in title_groups:
            title_groups[title] = {
                "names": set(),
                "conditions": set(),
                "hasDeposit": False,
                "hasWithdraw": False,
                "isRecommended": False
            }
        
        title_groups[title]["names"].add(name)
        title_groups[title]["hasWithdraw"] = True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
        key = f"{title}|||{name}"
        if key in recommended_set:
            title_groups[title]["isRecommended"] = True
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —É—Å–ª–æ–≤–∏—è
        conditions = extract_conditions_from_name(name)
        title_groups[title]["conditions"].update(conditions)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    sheets_data = []
    
    for title, group_data in title_groups.items():
        # –ü–æ–ª—É—á–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç
        min_deposit = None
        for name in group_data["names"]:
            key = f"{title}|||{name}"
            if key in min_deposit_by_key:
                dep_val = min_deposit_by_key[key]
                if isinstance(dep_val, (int, float)) and dep_val > 0:
                    if min_deposit is None or dep_val < min_deposit:
                        min_deposit = dep_val
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —É—Å–ª–æ–≤–∏—è
        conditions_str = "ALL"
        if group_data["conditions"]:
            conditions_str = "\\n".join(sorted(group_data["conditions"]))
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É
        row = {
            "Paymethod": title,
            "Payment Name": "\\n".join(sorted(group_data["names"])),
            "Currency": currency,
            "Deposit": "YES" if group_data["hasDeposit"] else "NO",
            "Withdraw": "YES" if group_data["hasWithdraw"] else "NO", 
            "Status": "PROD" if request.env == "prod" else "STAGE",
            "Details": conditions_str,
            "Min Dep": f"{min_deposit} {currency}".strip() if min_deposit else "‚Äî",
            "Recommended": "‚≠ê" if group_data["isRecommended"] else ""
        }
        
        sheets_data.append(row)
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–æ–π –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
    def is_crypto(title):
        title_lower = title.lower()
        crypto_keywords = ['btc', 'eth', 'ltc', 'usdt', 'usdc', 'trx', 'doge', 'ada', 'sol', 'xrp', 'bch', 'ton']
        return 'crypto' in title_lower or any(crypto in title_lower for crypto in crypto_keywords)
    
    def is_withdraw_only(row):
        return row["Deposit"] == "NO" and row["Withdraw"] == "YES"
    
    def get_base_crypto_name(title):
        # –£–±–∏—Ä–∞–µ–º " - –æ–ø–∏—Å–∞–Ω–∏–µ" –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
        return title.replace(' - ', ' ').strip()
    
    # –ü–æ–ª—É—á–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –∏–∑ —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    original_order = {}
    all_methods = deposit_methods + withdraw_methods
    for i, (title, name) in enumerate(all_methods):
        if title not in original_order:
            original_order[title] = i
    
    def get_crypto_sort_key(paymethod):
        # "Crypto" –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤–∞—è –≤ –∫—Ä–∏–ø—Ç–æ–±–ª–æ–∫–µ
        if paymethod == "Crypto":
            return (0, paymethod)
        else:
            return (1, get_base_crypto_name(paymethod))
    
    sheets_data.sort(key=lambda x: (
        is_withdraw_only(x),           # Withdraw-only –º–µ—Ç–æ–¥—ã –≤ —Å–∞–º—ã–π –∫–æ–Ω–µ—Ü
        is_crypto(x["Paymethod"]),     # –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã –ø–æ—Å–ª–µ –æ–±—ã—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
        not x["Recommended"] if not is_crypto(x["Paymethod"]) else False,  # –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ –≤–ø–µ—Ä–µ–¥ —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ-–∫—Ä–∏–ø—Ç–æ
        get_crypto_sort_key(x["Paymethod"]) if is_crypto(x["Paymethod"]) else (original_order.get(x["Paymethod"], 999), x["Paymethod"])  # –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –¥–ª—è –Ω–µ-–∫—Ä–∏–ø—Ç–æ, —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –¥–ª—è –∫—Ä–∏–ø—Ç–æ
    ))
    
    return {
        "success": True,
        "data": sheets_data,
        "currency": currency,
        "total_methods": len(sheets_data),
        "geo": request.geo,
        "project": request.project,
        "env": request.env
    }

# –≠–ù–î–ü–û–ò–ù–¢ –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–• –î–ï–ü–û–ó–ò–¢–û–í
@app.post("/get-min-deposits")
def get_min_deposits_endpoint(request: LoginTestRequest):
    res = get_methods_only(project=request.project, geo=request.geo, env=request.env, login=request.login)
    if not res.get("success"):
        raise HTTPException(status_code=400, detail=res.get("error", "Unknown error"))
    # –æ—Ç–¥–∞–¥–∏–º –æ–±–∞, —á—Ç–æ–±—ã —Ñ—Ä–æ–Ω—Ç –º–æ–≥ –≤—ã–±—Ä–∞—Ç—å –ª—é–±–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
    return {
        "success": True,
        "min_deposit_map": res.get("min_deposit_map", []),
        "min_deposits": res.get("min_deposits", []),
        "min_deposit_by_key": res.get("min_deposit_by_key", {})
    }

@app.post("/run-login-check")
def run_login_check_endpoint(request: LoginTestRequest):
    # ‚¨áÔ∏è –Ω–æ–≤–æ–µ:
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {
            "success": True,
            "currency": None,
            "deposit_count": 0,
            "skipped_geo": True,
        }

    return run_login_check(project=request.project, geo=request.geo, env=request.env, login=request.login)

@app.post("/run-multi-auth-check")
def run_multi_auth_check_endpoint(request: LoginTestRequest):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –¥–ª—è –≤—Å–µ—Ö –ª–æ–≥–∏–Ω–æ–≤ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º GEO
    """
    if request.mode != "geo":
        raise HTTPException(status_code=400, detail="Only 'geo' mode supported")
    
    if _is_geo_forbidden_for_project(request.project, request.geo):
        return {"results": []}
    
    if request.project not in EXTRACTORS:
        raise HTTPException(status_code=400, detail="Unknown project")
    
    # –ü–æ–ª—É—á–∞–µ–º –ª–æ–≥–∏–Ω—ã –¥–ª—è GEO
    effective_geo_groups = geo_groups
    if request.project == "Glitchspin":
        effective_geo_groups = {**geo_groups, **GLITCHSPIN_EXTRA_GEOS}
    elif request.project == "Vegazone":
        effective_geo_groups = {**geo_groups, **VEGASZONE_EXTRA_GEOS}
    
    logins = effective_geo_groups.get(request.geo, [])
    if not logins:
        return {"results": []}
    
    results = []
    extractor_class, stage_url, prod_url = EXTRACTORS[request.project]
    url = stage_url if request.env == "stage" else prod_url
    
    for login in logins:
        try:
            user_agent = (
                "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
                if "mobi" in login
                else "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15"
            )
            extractor = extractor_class(login, password_data, user_agent=user_agent, base_url=url)
            
            if extractor.authenticate():
                results.append({
                    "login": login,
                    "success": True,
                    "currency": extractor.currency,
                    "deposit_count": extractor.deposit_count
                })
            else:
                results.append({
                    "login": login,
                    "success": False,
                    "currency": None,
                    "deposit_count": 0
                })
        except Exception as e:
            results.append({
                "login": login,
                "success": False,
                "currency": None,
                "deposit_count": 0,
                "error": str(e)
            })
    
    return {"results": results}


@app.post("/test-methods")
async def test_methods(req: MethodTestRequest):
    # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤
    results = {
        "status": "not_implemented",
        "message": "–§—É–Ω–∫—Ü–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞",
        "project": req.project,
        "geo": req.geo,
        "login": req.login,
        "mode": req.mode,
        "env": req.env
    }
    return JSONResponse(content={"results": results})

@app.post("/export-table-to-sheets")
def export_table_to_sheets(payload: Dict = Body(...)):
    data: List[Dict] = payload.get("data", [])
    original_order: Optional[List[str]] = payload.get("originalOrder")
    project: str = payload.get("project", "Unknown")
    geo: str = payload.get("geo", "Unknown")
    env: str = payload.get("env", "prod")
    try:
        file_id = upload_table_to_sheets(data, original_order=original_order, project=project, geo=geo, env=env)
        sheet_url = f"https://docs.google.com/spreadsheets/d/{file_id}"
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
        safe_send_telegram_notification(
            sheet_url=sheet_url,
            project=project,
            geo=geo,
            env=env,
            export_type="single"
        )
        
        return {
            "success": True,
            "message": "–¢–∞–±–ª–∏—Ü–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ –≤ Google Sheets",
            "sheet_url": sheet_url
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        
# –≠–ö–°–ü–û–†–¢ FULL-–ü–†–û–ï–ö–¢–ê –í –õ–û–ö–ê–õ–¨–ù–´–ô EXCEL
@app.post("/export-full-project")
def export_full_project(req: FullProjectExportRequest, background_tasks: BackgroundTasks):
    if req.project not in [site["name"] for site in site_list]:
        raise HTTPException(status_code=400, detail="Unknown project")

    extractor_class, stage_url, prod_url = EXTRACTORS[req.project]
    url = stage_url if req.env == "stage" else prod_url

    filename = f"merged_{req.project}_{req.env}_FULL.xlsx"
    wb = openpyxl.Workbook()
    if 'Sheet' in wb.sheetnames:
        wb.remove(wb['Sheet'])

    for geo, logins in geo_groups.items():
        # ‚¨áÔ∏è –Ω–æ–≤–æ–µ:
        if _is_geo_forbidden_for_project(req.project, geo):
            logging.info(f"Skipping export for project '{req.project}' and forbidden geo '{geo}'")
            continue
        
        if not logins:
            continue

        all_payment_data = {}
        original_order = []
        method_type_map = {}
        recommended_set = set()
        seen_titles = set()
        currency = None
        conditions_raw = {} 

        min_by_title: Dict[str, float] = {}
        had_any_min = False

        for login in logins:
            user_agent = (
                "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X)"
                if "mobi" in login
                else "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
            )
            extractor = extractor_class(login, password_data, user_agent=user_agent, base_url=url)
            if not extractor.authenticate():
                continue

            deposit, withdraw, dep_names, wd_names, curr, _, recommended = extractor.get_payment_and_withdraw_systems(geo)
            currency = currency or curr

            deposit_pairs, dep_min_list = _extract_pairs_and_minlist(deposit, dep_names)
            withdraw_pairs, wd_min_list = _extract_pairs_and_minlist(withdraw, wd_names)
            
            if dep_min_list:
                had_any_min = True
                for row in dep_min_list:
                    title = row.get("title")
                    val = row.get("min_deposit")
                    if title is not None and val is not None:
                        try:
                            val_float = float(val)
                            if title not in min_by_title:
                                min_by_title[title] = val_float
                            else:
                                min_by_title[title] = min(min_by_title[title], val_float)
                        except (ValueError, TypeError):
                            continue

            all_pairs = deposit_pairs + withdraw_pairs

            for title, name in all_pairs:
                key = f"{title}|||{name}"
                if title not in seen_titles:
                    original_order.append(title)
                    seen_titles.add(title)

                method_type_map[key] = method_type_map.get(key, {"Deposit": "NO", "Withdraw": "NO"})
                if (title, name) in deposit_pairs:
                    method_type_map[key]["Deposit"] = "YES"
                if (title, name) in withdraw_pairs:
                    method_type_map[key]["Withdraw"] = "YES"

                all_payment_data.setdefault(login, {})[key] = {
                    "Payment Name": name,
                    "Deposit": method_type_map[key]["Deposit"],
                    "Withdraw": method_type_map[key]["Withdraw"],
                    "Status": req.env.upper()
                }

                tags = extract_tags(name)
                if tags:
                    combined = "+".join(tags)
                    if title not in conditions_raw:
                        conditions_raw[title] = set()
                    conditions_raw[title].add(combined)
                else:
                    if title not in conditions_raw:
                        conditions_raw[title] = set()
                    conditions_raw[title].add("ALL")

            recommended_set.update(recommended)

        conditions_map = {k: "\n".join(sorted(v)) if v else "ALL" for k, v in conditions_raw.items()}
        merged = merge_payment_data(
            all_payment_data,
            list(all_payment_data.keys()),
            original_order,
            currency,
            list(recommended_set),
            excel_filename=filename,
            url=url,
            conditions_map=conditions_map
        )

        sheet = wb.create_sheet(title=f"{req.project}_{geo}_{req.env}")
        headers = ["Paymethod", "Payment Name", "Currency", "Deposit", "Withdraw", "Status", "Min Deposit", "Details"]
        for col, header in enumerate(headers, start=1):
            sheet.cell(row=1, column=col, value=header)

        for i, method in enumerate(merged, start=2):
            row_min = min_by_title.get(method) if had_any_min else None
            row_data = [
                method, 
                merged[method].get("Payment Name", ""),
                merged[method].get("Currency", ""),
                merged[method].get("Deposit", ""),
                merged[method].get("Withdraw", ""),
                merged[method].get("Status", ""),
                row_min if row_min is not None else "",
                merged[method].get("Details", "")
            ]
            for col, val in enumerate(row_data, start=1):
                sheet.cell(row=i, column=col, value=val)

    if 'Sheet' in wb.sheetnames:
        wb.remove(wb['Sheet'])
    wb.save(filename)
    
    try:
        creds = get_credentials()
        file_metadata = {
            'name': filename,
            'mimeType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        }
        media = MediaFileUpload(filename, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        drive_service = build('drive', 'v3', credentials=creds)
        
        file = drive_service.files().create(body=file_metadata, media_body=media, fields='id').execute()
        file_id = file.get('id')
        
        os.remove(filename)

        return {
            "success": True,
            "message": "–ü—Ä–æ–µ–∫—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ GEO-–ª–∏—Å—Ç–∞–º–∏ –∏ –∑–∞–≥—Ä—É–∂–µ–Ω –Ω–∞ Google Drive",
            "sheet_url": f"https://docs.google.com/spreadsheets/d/{file_id}"
        }
    except Exception as e:
        logging.error(f"Failed to upload merged Excel file to Google Drive: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to upload file: {str(e)}")


# –≠–ö–°–ü–û–†–¢ FULL-–ü–†–û–ï–ö–¢–ê –í GOOGLE SHEETS
@app.post("/export-full-project-to-google-sheet")
def export_full_project_to_google_sheet(data: FullProjectExportRequest):
    """
    –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –≤—Å–µ GEO –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ –≤ –æ–¥–∏–Ω Google Sheet,
    –≥–¥–µ –∫–∞–∂–¥—ã–π GEO –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ª–∏—Å—Ç–µ.
    """
    try:
        creds = get_credentials()
        sheets_service = build("sheets", "v4", credentials=creds)
    except Exception as e:
        logging.error(f"Google API credentials error: {e}")
        raise HTTPException(status_code=500, detail=f"Google API credentials error: {e}")

    project = data.project
    env = data.env
    all_geo = list(geo_groups.keys())

    spreadsheet_body = { "properties": {"title": f"üìä {project} ({env.upper()}) ‚Äî Full Export"} }
    try:
        spreadsheet = sheets_service.spreadsheets().create(body=spreadsheet_body).execute()
        file_id = spreadsheet["spreadsheetId"]
        logging.info(f"Created new Google Sheet with ID: {file_id}")
    except Exception as e:
        logging.error(f"Failed to create Google Sheet: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create Google Sheet: {e}")

    sheets_to_add = []
    all_sheets_data = {}

    for geo in all_geo:
        # ‚¨áÔ∏è –Ω–æ–≤–æ–µ:
        if _is_geo_forbidden_for_project(project, geo):
            logging.info(f"Skipping sheet creation for project '{project}' and forbidden geo '{geo}'")
            continue
        
        logins = geo_groups.get(geo, [])
        if not logins:
            continue

        seen_methods = {}
        recommended_set = set()

        # –ú–∞–ø–∞ –¥–ª—è —Å–±–æ—Ä–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –¥–µ–ø–æ–∑–∏—Ç–æ–≤ –ø–æ –≤—Å–µ–º –ª–æ–≥–∏–Ω–∞–º –≤ —Ä–∞–º–∫–∞—Ö –æ–¥–Ω–æ–≥–æ GEO
        min_deposits_by_key_geo: Dict[str, Dict] = {}

        for login in logins:
            try:
                methods = get_methods_only(project=project, geo=geo, env=env, login=login)
                if not methods or not methods.get("success"):
                    continue
            except Exception as e:
                logging.warning(f"Could not fetch methods for {login} in {geo}: {e}")
                continue

            for (title, name) in methods.get("recommended_methods", []):
                recommended_set.add((title.strip(), name.strip()))

            deposit_pairs = methods.get("deposit_methods", [])
            withdraw_pairs = methods.get("withdraw_methods", [])
            all_pairs = set(deposit_pairs + withdraw_pairs)

            # –°–æ–±–∏—Ä–∞–µ–º –º–∏–Ω–∏–º—É–º—ã –¥–ª—è —ç—Ç–æ–≥–æ –ª–æ–≥–∏–Ω–∞ –∏ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤ –æ–±—â—É—é –º–∞–ø—É –ø–æ GEO
            min_deposits_map = { _key_join(d['title'], d['name']): d for d in methods.get('min_deposit_map', []) }
            for key, min_info in min_deposits_map.items():
                if key not in min_deposits_by_key_geo:
                    min_deposits_by_key_geo[key] = min_info
                else:
                    # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –º–µ–Ω—å—à–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –æ–±–Ω–æ–≤–ª—è–µ–º
                    current_min = min_deposits_by_key_geo[key].get('min_deposit')
                    new_min = min_info.get('min_deposit')
                    if new_min is not None and (current_min is None or new_min < current_min):
                        min_deposits_by_key_geo[key]['min_deposit'] = new_min

            for (title, name) in all_pairs:
                key = (title.strip(), name.strip())
                if key not in seen_methods:
                    seen_methods[key] = {
                        "Paymethod": title,
                        "Recommended": "",
                        "Deposit": "NO",
                        "Withdraw": "NO",
                        "Payment Name": name,
                        "Min Dep": "", 
                        "Conditions": extract_conditions_from_name(name),
                        "Env": env.upper()
                    }
                
                if (title, name) in deposit_pairs:
                    seen_methods[key]["Deposit"] = "YES"
                if (title, name) in withdraw_pairs:
                    seen_methods[key]["Withdraw"] = "YES"
                if (title, name) in recommended_set:
                    seen_methods[key]["Recommended"] = "‚≠ê"

        # –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª–µ "Min Dep" –ø–æ—Å–ª–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –ª–æ–≥–∏–Ω–æ–≤
        for key, method_data in seen_methods.items():
            min_info = min_deposits_by_key_geo.get(_key_join(key[0], key[1]))
            if min_info and min_info.get("min_deposit") is not None:
                method_data["Min Dep"] = f"{min_info['min_deposit']} {min_info.get('currency', '')}"

        if seen_methods:
            rows = list(seen_methods.values())
            headers = list(rows[0].keys())
            values = [headers] + [[r.get(h, "") for h in headers] for r in rows]
            
            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è NZ - –¥–æ–±–∞–≤–ª—è–µ–º –≤–∞–ª—é—Ç—É NZD
            if geo == "NZ":
                sheet_title = "NZ_NZD"
            else:
                sheet_title = geo
            sheet_title = sheet_title[:100]
            sheets_to_add.append({"addSheet": {"properties": {"title": sheet_title}}})
            all_sheets_data[sheet_title] = values

    if not sheets_to_add:
        try:
            drive_service = build('drive', 'v3', credentials=creds)
            drive_service.files().delete(fileId=file_id).execute()
        except Exception as e:
            logging.error(f"Could not delete empty spreadsheet {file_id}: {e}")
        return {"success": False, "message": "No data found for any GEO in this project."}
        
    try:
        sheets_service.spreadsheets().batchUpdate(
            spreadsheetId=file_id,
            body={"requests": sheets_to_add}
        ).execute()

        data_to_update = []
        for sheet_title, values in all_sheets_data.items():
            data_to_update.append({
                "range": f"'{sheet_title}'!A1",
                "values": values
            })
        
        sheets_service.spreadsheets().values().batchUpdate(
            spreadsheetId=file_id,
            body={
                "valueInputOption": "RAW",
                "data": data_to_update
            }
        ).execute()
        
    except Exception as e:
        logging.error(f"Failed to update sheets in batch: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update sheets: {e}")

    try:
        sheet_metadata = sheets_service.spreadsheets().get(spreadsheetId=file_id).execute()
        sheets = sheet_metadata.get('sheets', '')
        default_sheet_id = next((s['properties']['sheetId'] for s in sheets if s['properties']['title'] == 'Sheet1'), None)

        if default_sheet_id is not None:
             sheets_service.spreadsheets().batchUpdate(
                spreadsheetId=file_id,
                body={"requests": [{"deleteSheet": {"sheetId": default_sheet_id}}]}
            ).execute()
    except Exception:
        logging.warning("Could not delete default 'Sheet1'. It may not have existed.")

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    set_sheet_permissions(file_id)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
    sheet_url = f"https://docs.google.com/spreadsheets/d/{file_id}"
    safe_send_telegram_notification(
        sheet_url=sheet_url,
        project=req.project,
        env=req.env,
        export_type="full"
    )

    return {"success": True, "sheet_url": sheet_url}


# –≠–ö–°–ü–û–†–¢ –ù–ï–°–ö–û–õ–¨–ö–ò–• –¢–ê–ë–õ–ò–¶ –í GOOGLE SHEETS (–ü–û –§–†–û–ù–¢–£)
@app.post("/export-table-to-sheets-multi")
def export_table_to_sheets_multi(payload: Dict = Body(...)):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∞–±–ª–∏—Ü –ø–æ GEO –∏ –≤—ã–≥—Ä—É–∂–∞–µ—Ç –∏—Ö –≤ –æ–¥–∏–Ω Google Sheet (–ø–æ —Ñ—Ä–æ–Ω—Ç—É).
    """
    try:
        sheets = payload.get("sheets", [])
        project = payload.get("project", "Unknown")
        env = payload.get("env", "prod")
        if not sheets or not isinstance(sheets, list):
            raise HTTPException(status_code=400, detail="Invalid or missing 'sheets'")

        creds = get_credentials()
        sheets_service = build("sheets", "v4", credentials=creds)

        # –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Å –ø—Ä–æ–µ–∫—Ç–æ–º –≤ –Ω–∞—á–∞–ª–µ
        title = f"{project} - üìä Multi-GEO Export {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        spreadsheet_body = {
            "properties": {
                "title": title
            }
        }
        spreadsheet = sheets_service.spreadsheets().create(body=spreadsheet_body).execute()
        file_id = spreadsheet["spreadsheetId"]
        logging.info(f"Created new spreadsheet: {file_id}")

        requests = []
        data_to_update = [] 

        for sheet_data_item in sheets:
            geo = sheet_data_item.get("geo", "Sheet")
            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è NZ - –¥–æ–±–∞–≤–ª—è–µ–º –≤–∞–ª—é—Ç—É NZD
            if geo == "NZ":
                title = "NZ_NZD"
            else:
                title = geo
            title = title[:100]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –Ω–∞–∑–≤–∞–Ω–∏—è
            rows = sheet_data_item.get("rows", [])
            if not rows:
                continue

            requests.append({"addSheet": {"properties": {"title": title}}})
            headers = list(rows[0].keys())
            values = [headers] + [[r.get(h, "") for h in headers] for r in rows]
            
            data_to_update.append({
                "range": f"'{title}'!A1",
                "values": values
            })

        if not requests:
            return {"success": False, "message": "No valid data to export"}

        sheets_service.spreadsheets().batchUpdate(
            spreadsheetId=file_id,
            body={"requests": requests}
        ).execute()

        sheets_service.spreadsheets().values().batchUpdate(
            spreadsheetId=file_id,
            body={
                "valueInputOption": "RAW",
                "data": data_to_update
            }
        ).execute()

        try:
            metadata = sheets_service.spreadsheets().get(spreadsheetId=file_id).execute()
            for sheet_info in metadata.get("sheets", []):
                if sheet_info["properties"]["title"] == "Sheet1":
                    default_sheet_id = sheet_info["properties"]["sheetId"]
                    sheets_service.spreadsheets().batchUpdate(
                        spreadsheetId=file_id,
                        body={"requests": [{"deleteSheet": {"sheetId": default_sheet_id}}]}
                    ).execute()
                    logging.info(f"–£–¥–∞–ª–µ–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ª–∏—Å—Ç 'Sheet1' (ID: {default_sheet_id}).")
                    break
        except Exception as e:
            logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ª–∏—Å—Ç 'Sheet1': {e}")

        finalize_google_sheet_formatting(file_id, delete_columns_by_header=["RecommendedSort"])
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
        set_sheet_permissions(file_id)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
        sheet_url = f"https://docs.google.com/spreadsheets/d/{file_id}"
        safe_send_telegram_notification(
            sheet_url=sheet_url,
            project=project,
            env=env,
            export_type="multi"
        )

        return {
            "success": True,
            "sheet_url": sheet_url
        }

    except Exception as e:
        logging.error(f"Export failed: {e}")
        return {"success": False, "message": str(e)}


@app.post("/test-methods-v2")
def test_methods_v2(payload: Dict[str, Any]):
    """
    payload: {project, geo?, login?, mode: 'login'|'geo'|'project', env}
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç: {results: [{...—Ä–µ–∑—É–ª—å—Ç–∞—Ç..., checks:[], checks_summary:{passed,failed}}], meta:{sla_sec}}
    """
    from utils.assertions import run_smoke_checks
    
    # 1) –≤—ã–∑–æ–≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ä–∞–Ω–Ω–µ—Ä–∞ (–∫–∞–∫ –≤ /test-methods)
    # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤
    results = [{
        "status": "not_implemented",
        "message": "–§—É–Ω–∫—Ü–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞",
        "project": payload.get('project'),
        "geo": payload.get('geo'),
        "login": payload.get('login'),
        "mode": payload.get('mode'),
        "env": payload.get('env')
    }]

    # (optional) –ø–æ–¥—Ç—è–Ω—É—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏/–≤–∞–ª—é—Ç–µ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –±—ã—Å—Ç—Ä–æ)
    account_currency = None  # –µ—Å–ª–∏ —Ä–∞–Ω–Ω–µ—Ä –µ—ë –∑–Ω–∞–µ—Ç
    listing_index = {}  # key: (geo, login, method) -> {'deposit':bool,'withdraw':bool}
    # TODO: –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏: –∑–∞–ø—Ä–æ—Å–∏—Ç—å /get-methods-only –∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å listing_index

    out = []
    for r in results:
        key = (r.get('geo'), r.get('login'), r.get('method'))
        listing_hint = listing_index.get(key)
        checks, summary = run_smoke_checks(r, account_currency=account_currency, listing_hint=listing_hint)
        r2 = dict(r)
        r2['checks'] = checks
        r2['checks_summary'] = summary
        out.append(r2)

    return {'results': out, 'meta': {'sla_sec': 3.0}}


@app.post("/snapshot/project")
def snapshot_project(payload: Dict[str, Any]):
    """
    Generate YAML snapshot for a project
    payload: {project, env?, save?}
    returns: YAML text response
    """
    try:
        import yaml
        from utils.snapshot import build_snapshot
        
        project = payload.get("project")
        env = payload.get("env", "prod")
        save = bool(payload.get("save", False))
        
        if not project:
            raise HTTPException(status_code=400, detail="project is required")
        
        logging.info(f"Starting snapshot generation for project: {project}, env: {env}")
        
        # Get geo groups for project - simplified approach
        geo_to_logins = {}
        
        try:
            # Try to get geo groups from existing function
            geo_groups = get_geo_groups({"project": project})
            logging.info(f"Got geo groups response: {type(geo_groups)}")
            
            if isinstance(geo_groups, dict) and "geo_groups" in geo_groups:
                for geo_data in geo_groups["geo_groups"]:
                    geo = geo_data.get("geo")
                    logins = geo_data.get("logins", [])
                    if geo and logins:
                        geo_to_logins[geo] = logins[:2]  # Limit to 2 logins for testing
                        logging.info(f"Added geo {geo} with {len(logins)} logins")
        except Exception as e:
            logging.error(f"Error getting geo groups: {e}")
            import traceback
            traceback.print_exc()
        
        # If no geo groups found, create a minimal test structure
        if not geo_to_logins:
            logging.warning(f"No geo groups found for project {project}, creating test structure")
            geo_to_logins = {"TEST_GEO": ["test_login"]}
        
        # Build snapshot with methods fetching
        from datetime import datetime, timezone
        
        def run_login_fetcher(geo, login):
            try:
                result = run_login_check({
                    "project": project,
                    "geo": geo, 
                    "login": login,
                    "env": env
                })
                return result if isinstance(result, dict) else {}
            except Exception as e:
                logging.warning(f"Login check failed for {geo}/{login}: {e}")
                return {}
        
        def get_methods_fetcher(geo, login):
            try:
                result = get_methods_only({
                    "project": project,
                    "geo": geo,
                    "login": login, 
                    "env": env
                })
                return result if isinstance(result, dict) else {}
            except Exception as e:
                logging.warning(f"Get methods failed for {geo}/{login}: {e}")
                return {}
        
        # Build full snapshot
        snapshot = build_snapshot(
            project, env, geo_to_logins,
            fetchers={
                "run_login": run_login_fetcher,
                "get_methods": get_methods_fetcher
            }
        )
        
        # Convert to YAML
        yaml_text = yaml.safe_dump(snapshot, allow_unicode=True, sort_keys=False)
        
        if save:
            os.makedirs("snapshots", exist_ok=True)
            filename = f"snapshots/snapshot_{project}_{env}.yaml"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(yaml_text)
            logging.info(f"Snapshot saved to {filename}")
        
        return Response(content=yaml_text, media_type="text/yaml")
        
    except Exception as e:
        logging.error(f"Snapshot generation failed: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Snapshot generation failed: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)